<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MMRRC GO Term Mind Map</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .canvas-wrapper {
      overflow: hidden;
      position: relative;
    }
    .infinite-canvas {
      position: absolute;
      top: 0;
      left: 0;
      cursor: pointer;
    }
    .infinite-canvas.dragging-node {
      cursor: grabbing;
    }
    .infinite-canvas.dragging-canvas {
      cursor: grabbing;
    }
    .hover-panel {
      position: absolute;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 12px 16px;
      max-width: 280px;
      min-width: 200px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      pointer-events: none;
      z-index: 1000;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.2s ease-out;
    }
    .hover-panel.visible {
      opacity: 1;
      transform: translateY(0);
    }
    .hover-panel h4 {
      margin: 0 0 8px 0;
      font-size: 14px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.9);
      line-height: 1.3;
    }
    .hover-panel p {
      margin: 0 0 6px 0;
      font-size: 12px;
      color: rgba(0, 0, 0, 0.7);
      line-height: 1.4;
    }
    .hover-panel .term-id {
      font-family: monospace;
      font-size: 10px;
      color: rgba(0, 0, 0, 0.6);
      margin: 6px 0 0 0;
    }
    .hover-panel .loading {
      color: rgba(0, 0, 0, 0.5);
      font-style: italic;
    }
    .toast-notification {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 12px 16px;
      color: rgba(0, 0, 0, 0.8);
      font-size: 14px;
      font-weight: 500;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      z-index: 1001;
      opacity: 0;
      transform: translateY(-20px);
      transition: all 0.3s ease-out;
      pointer-events: none;
    }
    .toast-notification.visible {
      opacity: 1;
      transform: translateY(0);
    }
  </style>
</head>
<body class="bg-gray-100">
  <div class="mx-auto max-w-[1130px] flex h-screen">
    <!-- Column 1 -->
    <div id="canvas-wrapper" class="w-2/3 bg-white border-r relative canvas-wrapper">
      <canvas id="canvas" class="infinite-canvas" width="2000" height="2000"></canvas>
      <div id="hover-panel" class="hover-panel">
        <h4 id="hover-title">Term Name</h4>
        <p id="hover-description">Loading...</p>
        <div id="hover-id" class="term-id">GO:0000000</div>
      </div>
      <div id="toast-notification" class="toast-notification">
        No child GO terms
      </div>
    </div>

    <!-- Column 2 -->
    <div id="details" class="w-1/3 p-4 overflow-y-auto">
      <h2 class="text-xl font-semibold mb-2">GO Term Details</h2>
      <div id="term-info" class="mb-4">
        <p class="text-gray-600">Click a term to see details</p>
      </div>
      <h3 class="text-lg font-semibold mb-2">Related Mouse Strains</h3>
      <ul id="strainList" class="list-disc list-inside text-blue-600"></ul>
    </div>
  </div>

  <script>
    const ROOT_TERMS = [
      "http://purl.obolibrary.org/obo/GO_0008150",
      "http://purl.obolibrary.org/obo/GO_0005575", 
      "http://purl.obolibrary.org/obo/GO_0003674"
    ];

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    
    let nodes = {}; // Map from GO ID to { x, y, lbl, children: [GO ID], parent, pred }
    let panX = 0;
    let panY = 0;
    let zoomLevel = 1;
    const minZoom = 0.3;
    const maxZoom = 3;
    const zoomSpeed = 0.1;
    
    // Performance optimization variables
    let isProcessing = false;
    let lastClickTime = 0;
    const clickDebounceTime = 300; // ms
    let renderFrame = null;
    let needsRedraw = false;
    
    // Ripple effect variables
    let ripples = [];
    let toastTimeout = null;
    let rippleAnimationId = null;

    const colorsByPred = {
      "is_a": "#3490dc",
      "http://purl.obolibrary.org/obo/BFO_0000050": "#38c172", 
      "http://purl.obolibrary.org/obo/RO_0002213": "#ffed4a",
      "http://purl.obolibrary.org/obo/RO_0002212": "#6c757d",
      "http://purl.obolibrary.org/obo/RO_0002211": "#1a237e"
    };

    // Family colors for glassmorphism effect
    const familyColors = {
      "http://purl.obolibrary.org/obo/GO_0008150": {
        bg: "rgba(59, 130, 246, 0.15)", // Blue glass
        border: "rgba(59, 130, 246, 0.3)",
        text: "rgba(30, 64, 175, 0.9)"
      },
      "http://purl.obolibrary.org/obo/GO_0005575": {
        bg: "rgba(34, 197, 94, 0.15)", // Green glass
        border: "rgba(34, 197, 94, 0.3)", 
        text: "rgba(21, 128, 61, 0.9)"
      },
      "http://purl.obolibrary.org/obo/GO_0003674": {
        bg: "rgba(239, 68, 68, 0.15)", // Red glass
        border: "rgba(239, 68, 68, 0.3)",
        text: "rgba(153, 27, 27, 0.9)"
      }
    };

    function getRootFamily(nodeId) {
      let current = nodes[nodeId];
      while (current && current.parent) {
        current = nodes[current.parent];
      }
      return current ? current.id : null;
    }

    function getFamilyStyle(nodeId) {
      const rootFamily = getRootFamily(nodeId);
      return familyColors[rootFamily] || {
        bg: "rgba(255, 255, 255, 0.15)", // Default glass
        border: "rgba(255, 255, 255, 0.3)",
        text: "rgba(0, 0, 0, 0.8)"
      };
    }

    function getRippleColor(nodeId) {
      const rootFamily = getRootFamily(nodeId);
      const rippleColors = {
        "http://purl.obolibrary.org/obo/GO_0008150": "rgba(59, 130, 246, 1)", // Blue
        "http://purl.obolibrary.org/obo/GO_0005575": "rgba(34, 197, 94, 1)", // Green
        "http://purl.obolibrary.org/obo/GO_0003674": "rgba(239, 68, 68, 1)"  // Red
      };
      return rippleColors[rootFamily] || "rgba(156, 163, 175, 1)"; // Gray default
    }

    function drawRipples() {
      for (let i = ripples.length - 1; i >= 0; i--) {
        const ripple = ripples[i];
        const progress = (Date.now() - ripple.startTime) / ripple.duration;
        
        if (progress >= 1) {
          ripples.splice(i, 1);
          continue;
        }
        
        ctx.save();
        
        // Calculate ripple properties
        const currentRadius = ripple.maxRadius * progress;
        const opacity = Math.max(0, (1 - progress) * 0.6);
        
        // Draw ripple circle
        ctx.beginPath();
        ctx.arc(
          (ripple.x * zoomLevel) + panX,
          (ripple.y * zoomLevel) + panY,
          currentRadius * zoomLevel,
          0,
          Math.PI * 2
        );
        
        ctx.strokeStyle = ripple.color.replace('1)', `${opacity})`);
        ctx.lineWidth = 3 * zoomLevel;
        ctx.stroke();
        
        // Draw inner filled circle that shrinks
        const innerRadius = (ripple.maxRadius * 0.3) * (1 - progress);
        if (innerRadius > 0) {
          ctx.beginPath();
          ctx.arc(
            (ripple.x * zoomLevel) + panX,
            (ripple.y * zoomLevel) + panY,
            innerRadius * zoomLevel,
            0,
            Math.PI * 2
          );
          ctx.fillStyle = ripple.color.replace('1)', `${opacity * 0.3})`);
          ctx.fill();
        }
        
        ctx.restore();
      }
    }

    function animateRipples() {
      if (ripples.length > 0) {
        requestRedraw();
        rippleAnimationId = requestAnimationFrame(animateRipples);
      } else {
        rippleAnimationId = null;
      }
    }

    function createRipple(x, y, color) {
      ripples.push({
        x: x,
        y: y,
        startTime: Date.now(),
        duration: 800, // ms
        maxRadius: 80,
        color: color
      });
      
      // Start ripple animation if not already running
      if (!rippleAnimationId) {
        rippleAnimationId = requestAnimationFrame(animateRipples);
      }
    }

    function showToast() {
      const toast = document.getElementById('toast-notification');
      
      // Clear any existing timeout
      if (toastTimeout) {
        clearTimeout(toastTimeout);
        toastTimeout = null;
      }
      
      // Show toast
      toast.classList.add('visible');
      
      // Hide after 2 seconds
      toastTimeout = setTimeout(() => {
        toast.classList.remove('visible');
        toastTimeout = null;
      }, 2000);
    }

    // API functions for your backend
    async function fetchGOTerm(id) {
      try {
        const res = await fetch(`http://localhost:3000/api/go/${encodeURIComponent(id)}`);
        return res.ok ? await res.json() : null;
      } catch (error) {
        console.error('Error fetching GO term:', error);
        return null;
      }
    }

    async function fetchChildren(id) {
      try {
        const res = await fetch(`http://localhost:3000/api/go/children/${encodeURIComponent(id)}`);
        return res.ok ? await res.json() : [];
      } catch (error) {
        console.error('Error fetching children:', error);
        return [];
      }
    }

    function drawLine(x1, y1, x2, y2, pred) {
      const startX = (x1 * zoomLevel) + panX;
      const startY = (y1 * zoomLevel) + panY;
      const endX = (x2 * zoomLevel) + panX;
      const endY = (y2 * zoomLevel) + panY;
      const radius = 40 * zoomLevel;
      
      // Calculate line direction
      const dx = endX - startX;
      const dy = endY - startY;
      const length = Math.sqrt(dx * dx + dy * dy);
      
      if (length === 0) return;
      
      // Normalize direction
      const dirX = dx / length;
      const dirY = dy / length;
      
      // Calculate intersection points with circles
      const startOffsetX = startX + (dirX * radius);
      const startOffsetY = startY + (dirY * radius);
      const endOffsetX = endX - (dirX * radius);
      const endOffsetY = endY - (dirY * radius);
      
      ctx.save();
      
      // Create gradient for line that fades near circles
      const gradient = ctx.createLinearGradient(startOffsetX, startOffsetY, endOffsetX, endOffsetY);
      const color = colorsByPred[pred] || colorsByPred.default;
      
      // Extract RGB from hex color
      const r = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b = parseInt(color.slice(5, 7), 16);
      
      gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0)`); // Transparent at start
      gradient.addColorStop(0.15, `rgba(${r}, ${g}, ${b}, 0.3)`); // Fade in
      gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 1)`); // Full opacity in middle
      gradient.addColorStop(0.85, `rgba(${r}, ${g}, ${b}, 0.3)`); // Fade out
      gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`); // Transparent at end
      
      ctx.beginPath();
      ctx.strokeStyle = gradient;
      ctx.lineWidth = 2 * zoomLevel;
      ctx.moveTo(startOffsetX, startOffsetY);
      ctx.lineTo(endOffsetX, endOffsetY);
      ctx.stroke();
      
      ctx.restore();
    }

    function transformNodeLabel(label) {
      if (!label) return label;
      
      // Apply regex transformations to shorten common terms
      let transformed = label
        .replace(/positive regulation/gi, '+ reg')
        .replace(/negative regulation/gi, '- reg');
      
      return transformed;
    }

    function drawCircle(node) {
      const x = (node.x * zoomLevel) + panX;
      const y = (node.y * zoomLevel) + panY;
      const radius = 40 * zoomLevel;
      const style = getFamilyStyle(node.id);
      
      // Create glassmorphism effect
      ctx.save();
      
      // Draw shadow first
      ctx.beginPath();
      ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
      ctx.arc(x + (2 * zoomLevel), y + (2 * zoomLevel), radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw main circle with glassmorphism
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      
      // Create gradient for more glass-like effect
      const gradient = ctx.createRadialGradient(
        x - (10 * zoomLevel), y - (10 * zoomLevel), 0, 
        x, y, radius
      );
      gradient.addColorStop(0, style.bg.replace('0.15', '0.25')); // Brighter center
      gradient.addColorStop(1, style.bg);
      
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Draw border with glassmorphism
      ctx.strokeStyle = style.border;
      ctx.lineWidth = 1.5 * zoomLevel;
      ctx.stroke();
      
      // Add inner highlight for glass effect
      ctx.beginPath();
      ctx.arc(x - (8 * zoomLevel), y - (8 * zoomLevel), 12 * zoomLevel, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
      ctx.fill();
      
      ctx.restore();
      
      // Draw text with family color - scale font size with zoom
      ctx.fillStyle = style.text;
      ctx.font = `${12 * zoomLevel}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      
      // Only draw text if zoom level is reasonable for readability
      if (zoomLevel > 0.4) {
        // Transform the label to shorten common terms
        const transformedLabel = transformNodeLabel(node.lbl);
        
        // Split long labels into multiple lines
        const words = transformedLabel.split('_');
        if (words.length > 1 && transformedLabel.length > 12) {
          ctx.fillText(words[0], x, y - (6 * zoomLevel));
          ctx.fillText(words.slice(1).join('_').slice(0, 10), x, y + (6 * zoomLevel));
        } else {
          ctx.fillText(transformedLabel.slice(0, 12), x, y);
        }
      }
    }

    function requestRedraw() {
      if (needsRedraw || renderFrame) return;
      
      needsRedraw = true;
      renderFrame = requestAnimationFrame(() => {
        redrawCanvas();
        needsRedraw = false;
        renderFrame = null;
      });
    }

    function redrawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Early exit if no nodes
      if (Object.keys(nodes).length === 0) return;
      
      // Collect visible nodes for batch processing
      const visibleNodes = [];
      const visibleConnections = [];
      
      for (const id in nodes) {
        const node = nodes[id];
        if (node.visible === false) continue;
        
        visibleNodes.push(node);
        
        // Collect connections
        for (const childId of node.children) {
          const child = nodes[childId];
          if (child && child.visible !== false) {
            visibleConnections.push({ parent: node, child: child });
          }
        }
      }
      
      // Draw all connections first
      ctx.save();
      for (const connection of visibleConnections) {
        drawLine(connection.parent.x, connection.parent.y, connection.child.x, connection.child.y, connection.child.pred);
      }
      ctx.restore();
      
      // Draw all visible nodes on top
      ctx.save();
      for (const node of visibleNodes) {
        drawCircle(node);
      }
      ctx.restore();
      
      // Draw ripples on top of everything
      if (ripples.length > 0) {
        drawRipples();
      }
    }

    function findBestDirection(parentX, parentY, existingNodes) {
      // Test 8 main directions
      const directions = [
        { angle: 0, weight: 0 },           // East
        { angle: Math.PI / 4, weight: 0 }, // Northeast  
        { angle: Math.PI / 2, weight: 0 }, // North
        { angle: 3 * Math.PI / 4, weight: 0 }, // Northwest
        { angle: Math.PI, weight: 0 },     // West
        { angle: 5 * Math.PI / 4, weight: 0 }, // Southwest
        { angle: 3 * Math.PI / 2, weight: 0 }, // South
        { angle: 7 * Math.PI / 4, weight: 0 }  // Southeast
      ];

      // Calculate weights based on existing visible nodes
      for (const nodeId in existingNodes) {
        const node = existingNodes[nodeId];
        if (node.visible === false) continue;
        
        const dx = node.x - parentX;
        const dy = node.y - parentY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0 && distance < 400) { // Only consider nearby nodes
          const nodeAngle = Math.atan2(dy, dx);
          
          // Add weight to directions that would place children near existing nodes
          directions.forEach(dir => {
            let angleDiff = Math.abs(dir.angle - nodeAngle);
            if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
            
            if (angleDiff < Math.PI / 3) { // Within 60 degrees
              dir.weight += (400 - distance) / distance; // Closer nodes have more weight
            }
          });
        }
      }

      // Find direction with lowest weight (least crowded)
      return directions.reduce((best, current) => 
        current.weight < best.weight ? current : best
      );
    }

    function calculateOptimalLayout(parentX, parentY, childCount, preferredDirection) {
      // Adaptive radius based on number of children
      let radius;
      if (childCount <= 3) radius = 120;
      else if (childCount <= 6) radius = 160;
      else if (childCount <= 10) radius = 200;
      else radius = Math.max(200, childCount * 15);

      // Adaptive angular spread
      let totalAngle;
      if (childCount <= 4) {
        totalAngle = Math.PI; // 180 degrees for few children
      } else if (childCount <= 8) {
        totalAngle = 3 * Math.PI / 2; // 270 degrees for medium
      } else {
        totalAngle = 2 * Math.PI; // Full circle for many
      }

      const positions = [];
      const startAngle = preferredDirection.angle - totalAngle / 2;
      
      for (let i = 0; i < childCount; i++) {
        const angle = startAngle + (i * totalAngle) / Math.max(1, childCount - 1);
        const x = parentX + radius * Math.cos(angle);
        const y = parentY + radius * Math.sin(angle);
        positions.push({ x, y, angle });
      }

      return positions;
    }

    function avoidOverlaps(positions, existingNodes, minDistance = 100) {
      const adjustedPositions = [...positions];
      
      for (let i = 0; i < adjustedPositions.length; i++) {
        let pos = adjustedPositions[i];
        let adjusted = false;
        
        // Check against existing visible nodes
        for (const nodeId in existingNodes) {
          const node = existingNodes[nodeId];
          if (node.visible === false) continue;
          
          const dx = pos.x - node.x;
          const dy = pos.y - node.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < minDistance) {
            // Push away from existing node
            const pushAngle = Math.atan2(dy, dx);
            const pushDistance = minDistance - distance + 20;
            pos.x += pushDistance * Math.cos(pushAngle);
            pos.y += pushDistance * Math.sin(pushAngle);
            adjusted = true;
          }
        }
        
        // Check against other new positions
        for (let j = 0; j < adjustedPositions.length; j++) {
          if (i === j) continue;
          
          const other = adjustedPositions[j];
          const dx = pos.x - other.x;
          const dy = pos.y - other.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < minDistance) {
            // Push positions apart
            const pushAngle = Math.atan2(dy, dx);
            const pushDistance = (minDistance - distance) / 2 + 10;
            pos.x += pushDistance * Math.cos(pushAngle);
            pos.y += pushDistance * Math.sin(pushAngle);
            other.x -= pushDistance * Math.cos(pushAngle);
            other.y -= pushDistance * Math.sin(pushAngle);
            adjusted = true;
          }
        }
        
        adjustedPositions[i] = pos;
      }
      
      return adjustedPositions;
    }

    function hideAllDescendants(nodeId) {
      const node = nodes[nodeId];
      if (!node) return;
      
      // Use iterative approach instead of recursion for better performance
      const stack = [...node.children];
      
      while (stack.length > 0) {
        const childId = stack.pop();
        const child = nodes[childId];
        if (child) {
          child.visible = false;
          // Add children to stack for processing
          stack.push(...child.children);
        }
      }
    }

    function showDirectChildren(nodeId) {
      const node = nodes[nodeId];
      if (!node) return;
      
      // Simple loop - no recursion needed
      for (const childId of node.children) {
        const child = nodes[childId];
        if (child) {
          child.visible = true;
        }
      }
    }

    async function toggleNode(id) {
      // Debounce rapid clicks
      const currentTime = Date.now();
      if (isProcessing || currentTime - lastClickTime < clickDebounceTime) {
        return;
      }
      
      lastClickTime = currentTime;
      isProcessing = true;

      try {
        if (!nodes[id] || isAnimating) return;

        const parent = nodes[id];

        // If node has no children (already checked before), show ripple effect
        if (parent.childrenLoaded && parent.hasChildren === false) {
          const rippleColor = getRippleColor(id);
          createRipple(parent.x, parent.y, rippleColor);
          showToast();
          requestRedraw();
          return;
        }

        // If children are currently visible, hide them
        if (parent.childrenLoaded && parent.children.some(childId => nodes[childId]?.visible !== false)) {
          hideAllDescendants(id);
          requestRedraw();
          return;
        }

        // If node has no children loaded yet, fetch and show them
        if (!parent.childrenLoaded) {
          const children = await fetchChildren(id);

          if (children.length === 0) {
            parent.childrenLoaded = true;
            parent.hasChildren = false;
            
            // Create ripple effect and show toast
            const rippleColor = getRippleColor(id);
            createRipple(parent.x, parent.y, rippleColor);
            showToast();
            
            requestRedraw();
            return;
          }

          // Find the best direction to place children
          const bestDirection = findBestDirection(parent.x, parent.y, nodes);
          
          // Calculate optimal positions
          let positions = calculateOptimalLayout(parent.x, parent.y, children.length, bestDirection);
          
          // Avoid overlaps with existing nodes
          positions = avoidOverlaps(positions, nodes);

          // Store the new children positions for the animation
          const newChildrenPositions = [];

          // Create child nodes in batches for better performance
          const childPromises = children.map(async (child, i) => {
            const term = await fetchGOTerm(child.sub);
            if (!term) return null;

            const pos = positions[i];
            return {
              id: child.sub,
              lbl: term.lbl || child.sub,
              x: pos.x,
              y: pos.y,
              parent: id,
              pred: child.pred,
              children: [],
              childrenLoaded: false,
              visible: true,
              hasChildren: true,
              pos: pos
            };
          });

          const childNodes = await Promise.all(childPromises);
          
          // Add nodes to the graph
          for (const node of childNodes) {
            if (node) {
              nodes[node.id] = node;
              parent.children.push(node.id);
              newChildrenPositions.push(node.pos);
            }
          }
          
          parent.childrenLoaded = true;
          
          // Move other families away with animation
          moveOtherFamiliesAway(id, newChildrenPositions);
          
          // If no animation was triggered, just redraw
          if (!isAnimating) {
            requestRedraw();
          }
        } else {
          // Children exist but are hidden, show them
          showDirectChildren(id);
          requestRedraw();
        }
      } finally {
        isProcessing = false;
      }
    }

    let animationFrame = null;
    let isAnimating = false;

    function animateNodes(targetPositions, duration = 800) {
      if (isAnimating) return;
      
      isAnimating = true;
      const startTime = performance.now();
      const startPositions = {};
      
      // Store starting positions
      for (const id in targetPositions) {
        if (nodes[id]) {
          startPositions[id] = { x: nodes[id].x, y: nodes[id].y };
        }
      }

      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Smooth easing function (ease-out)
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        
        // Interpolate positions
        for (const id in targetPositions) {
          if (nodes[id] && startPositions[id]) {
            const start = startPositions[id];
            const target = targetPositions[id];
            
            nodes[id].x = start.x + (target.x - start.x) * easeProgress;
            nodes[id].y = start.y + (target.y - start.y) * easeProgress;
          }
        }
        
        redrawCanvas();
        
        if (progress < 1) {
          animationFrame = requestAnimationFrame(animate);
        } else {
          isAnimating = false;
          animationFrame = null;
        }
      }
      
      animationFrame = requestAnimationFrame(animate);
    }

    function moveOtherFamiliesAway(expandedNodeId, newChildrenPositions) {
      const expandedNode = nodes[expandedNodeId];
      if (!expandedNode) return;

      const movements = {};
      
      // Calculate the bounding box of the new children plus parent
      const allPositions = [...newChildrenPositions, { x: expandedNode.x, y: expandedNode.y }];
      const childBounds = {
        minX: Math.min(...allPositions.map(p => p.x)),
        maxX: Math.max(...allPositions.map(p => p.x)),
        minY: Math.min(...allPositions.map(p => p.y)),
        maxY: Math.max(...allPositions.map(p => p.y))
      };
      
      // Add padding to create exclusion zone - 25% increase from 150 to 188
      const exclusionPadding = 188;
      childBounds.minX -= exclusionPadding;
      childBounds.maxX += exclusionPadding;
      childBounds.minY -= exclusionPadding;
      childBounds.maxY += exclusionPadding;

      // Calculate the center of the expanded family
      const familyCenterX = (childBounds.minX + childBounds.maxX) / 2;
      const familyCenterY = (childBounds.minY + childBounds.maxY) / 2;

      // Find all nodes that need to be moved
      for (const nodeId in nodes) {
        const node = nodes[nodeId];
        if (node.visible === false) continue; // Skip hidden nodes
        
        // Skip nodes that are part of the expanded family
        if (nodeId === expandedNodeId || isDescendantOf(nodeId, expandedNodeId)) {
          continue;
        }

        // Check if node is within the exclusion zone or too close
        const inExclusionZone = (
          node.x >= childBounds.minX && node.x <= childBounds.maxX &&
          node.y >= childBounds.minY && node.y <= childBounds.maxY
        );

        // Also check distance to family center - 25% increase from 200 to 250
        const dx = node.x - familyCenterX;
        const dy = node.y - familyCenterY;
        const distanceToCenter = Math.sqrt(dx * dx + dy * dy);
        const tooClose = distanceToCenter < 250;

        if (inExclusionZone || tooClose) {
          // Calculate push direction from family center
          const pushDirection = distanceToCenter > 0 ? 
            { x: dx / distanceToCenter, y: dy / distanceToCenter } : 
            { x: 1, y: 0 }; // Default direction if at center
          
          // Push distance - 25% increase from 300 to 375
          const basePushDistance = 375;
          // Extra push threshold - 25% increase from 200 to 250
          const extraPush = Math.max(0, 250 - distanceToCenter);
          const totalPushDistance = basePushDistance + extraPush;
          
          const newX = node.x + pushDirection.x * totalPushDistance;
          const newY = node.y + pushDirection.y * totalPushDistance;
          
          movements[nodeId] = { x: newX, y: newY };
          
          // Move this node's entire family tree
          moveEntireFamily(nodeId, pushDirection.x * totalPushDistance, pushDirection.y * totalPushDistance, movements);
        }
      }
      
      // Apply movements with smooth animation
      if (Object.keys(movements).length > 0) {
        animateNodes(movements, 1000); // Slightly shorter animation
      }
    }

    function isDescendantOf(nodeId, ancestorId) {
      let current = nodes[nodeId];
      while (current && current.parent) {
        if (current.parent === ancestorId) return true;
        current = nodes[current.parent];
      }
      return false;
    }

    function moveNodeAndDescendants(node, deltaX, deltaY) {
      // Move the node itself
      node.x += deltaX;
      node.y += deltaY;
      
      // Recursively move all children and their descendants
      for (const childId of node.children) {
        const child = nodes[childId];
        if (child && child.visible !== false) {
          moveNodeAndDescendants(child, deltaX, deltaY);
        }
      }
    }

    function moveEntireFamily(rootId, deltaX, deltaY, movements) {
      const visited = new Set();
      
      function moveNodeAndChildren(nodeId) {
        if (visited.has(nodeId) || !nodes[nodeId]) return;
        visited.add(nodeId);
        
        const node = nodes[nodeId];
        if (!movements[nodeId]) { // Don't override if already moved
          movements[nodeId] = {
            x: node.x + deltaX,
            y: node.y + deltaY
          };
        }
        
        // Move all children recursively
        for (const childId of node.children) {
          moveNodeAndChildren(childId);
        }
      }
      
      moveNodeAndChildren(rootId);
    }

    let hoveredNode = null;
    let hoverPanel = null;
    let hoverTimeout = null;

    // Initialize hover panel
    function initHoverPanel() {
      hoverPanel = document.getElementById('hover-panel');
    }

    function showHoverPanel(node, mouseX, mouseY) {
      if (!hoverPanel) return;
      
      // Clear any existing timeout
      if (hoverTimeout) {
        clearTimeout(hoverTimeout);
      }
      
      // Update panel content immediately with basic info
      document.getElementById('hover-title').textContent = node.lbl || 'Loading...';
      document.getElementById('hover-description').textContent = 'Loading term details...';
      document.getElementById('hover-description').className = 'loading';
      document.getElementById('hover-id').textContent = node.id;
      
      // Position the panel near the mouse
      const rect = canvas.getBoundingClientRect();
      let panelX = mouseX + 15;
      let panelY = mouseY - 10;
      
      // Keep panel within canvas bounds
      const panelWidth = 280;
      const panelHeight = 100;
      
      if (panelX + panelWidth > rect.width) {
        panelX = mouseX - panelWidth - 15;
      }
      if (panelY + panelHeight > rect.height) {
        panelY = mouseY - panelHeight + 10;
      }
      if (panelY < 0) panelY = 10;
      
      hoverPanel.style.left = panelX + 'px';
      hoverPanel.style.top = panelY + 'px';
      hoverPanel.classList.add('visible');
      
      // Fetch detailed term info
      fetchGOTerm(node.id).then(term => {
        if (hoveredNode && hoveredNode.id === node.id && term) {
          // Only update if we're still hovering the same node
          document.getElementById('hover-title').textContent = term.lbl || node.lbl;
          
          // Create a nice description using the correct schema path
          let description = '';
          if (term.meta && term.meta.definition && term.meta.definition.val) {
            description = term.meta.definition.val.length > 120 ? 
              term.meta.definition.val.substring(0, 120) + '...' : 
              term.meta.definition.val;
          } else {
            description = 'No description available';
          }
          
          document.getElementById('hover-description').textContent = description;
          document.getElementById('hover-description').className = '';
        }
      }).catch(error => {
        if (hoveredNode && hoveredNode.id === node.id) {
          document.getElementById('hover-description').textContent = 'Error loading term details';
          document.getElementById('hover-description').className = '';
        }
      });
    }

    function hideHoverPanel() {
      if (!hoverPanel) return;
      
      hoverTimeout = setTimeout(() => {
        hoverPanel.classList.remove('visible');
        hoveredNode = null;
      }, 50); // Small delay to prevent flickering
    }

    function getHoveredNode(mouseX, mouseY) {
      const mousePos = {
        x: (mouseX - panX) / zoomLevel,
        y: (mouseY - panY) / zoomLevel
      };

      for (const id in nodes) {
        const node = nodes[id];
        if (node.visible === false) continue;
        
        const dx = mousePos.x - node.x;
        const dy = mousePos.y - node.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= 40) {
          return node;
        }
      }
      return null;
    }

    canvas.addEventListener("click", async (e) => {
      // Click events are now handled in mouseup to distinguish from drag
      // This prevents double-triggering of toggleNode
      e.preventDefault();
    });

    function showTermDetails(id) {
      const node = nodes[id];
      const termInfo = document.getElementById("term-info");
      const strainList = document.getElementById("strainList");
      
      termInfo.innerHTML = `
        <h3 class="font-semibold">${node.lbl}</h3>
        <p class="text-sm text-gray-600">${id}</p>
        <p class="text-xs text-gray-500 mt-1">Loading strain data...</p>
      `;

      // Fetch detailed term info from backend
      fetchGOTerm(id).then(term => {
        if (term) {
          termInfo.innerHTML = `
            <h3 class="font-semibold">${term.lbl || node.lbl}</h3>
            <p class="text-sm text-gray-600">${id}</p>
          `;

          if (term.mmrrcStrains && term.mmrrcStrains.length > 0) {
            strainList.innerHTML = term.mmrrcStrains.map(strain => 
              `<li><a href="${strain}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">${strain}</a></li>`
            ).join('');
          } else {
            strainList.innerHTML = '<li class="text-gray-500">No linked strains found</li>';
          }
        }
      }).catch(error => {
        console.error('Error loading term details:', error);
        termInfo.innerHTML += `<p class="text-red-500 text-xs">Error loading details</p>`;
      });
    }

    // Pan the canvas
    let isDragging = false;
    let isDraggingNode = false;
    let draggedNode = null;
    let dragStartTime = 0;
    let lastX, lastY;
    let lastNodeX, lastNodeY; // Track last node position for delta calculation
    const dragThreshold = 150; // ms to distinguish between click and drag

    canvas.addEventListener("mousedown", (e) => {
      const mousePos = getMousePos(e);
      let clickedNode = null;
      
      // Check if clicking on a node first
      for (const id in nodes) {
        const node = nodes[id];
        if (node.visible === false) continue;
        
        const dx = mousePos.x - node.x;
        const dy = mousePos.y - node.y;
        if (dx * dx + dy * dy <= 40 * 40) {
          clickedNode = node;
          break;
        }
      }
      
      if (clickedNode) {
        // Prepare for potential node dragging
        draggedNode = clickedNode;
        dragStartTime = Date.now();
        lastX = e.clientX;
        lastY = e.clientY;
        lastNodeX = clickedNode.x;
        lastNodeY = clickedNode.y;
      } else {
        // Start canvas panning
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      }
    });

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left - panX) / zoomLevel,
        y: (e.clientY - rect.top - panY) / zoomLevel
      };
    }

    // Add hover functionality
    canvas.addEventListener("mousemove", (e) => {
      // Handle canvas panning
      if (isDragging) {
        canvas.className = "infinite-canvas dragging-canvas";
        const deltaX = e.clientX - lastX;
        const deltaY = e.clientY - lastY;
        
        panX += deltaX;
        panY += deltaY;
        
        lastX = e.clientX;
        lastY = e.clientY;
        
        requestRedraw();
        return;
      }

      // Handle node dragging
      if (draggedNode && !isDraggingNode) {
        const deltaX = Math.abs(e.clientX - lastX);
        const deltaY = Math.abs(e.clientY - lastY);
        const timeDiff = Date.now() - dragStartTime;
        
        // Start dragging if mouse moved enough or held long enough
        if ((deltaX > 5 || deltaY > 5) || timeDiff > dragThreshold) {
          isDraggingNode = true;
          canvas.className = "infinite-canvas dragging-node";
          hideHoverPanel(); // Hide hover panel during drag
        }
      }

      if (isDraggingNode && draggedNode) {
        // Calculate movement delta in world coordinates
        const deltaX = e.clientX - lastX;
        const deltaY = e.clientY - lastY;
        
        const worldDeltaX = deltaX / zoomLevel;
        const worldDeltaY = deltaY / zoomLevel;
        
        // Move the dragged node and all its descendants
        moveNodeAndDescendants(draggedNode, worldDeltaX, worldDeltaY);
        
        lastX = e.clientX;
        lastY = e.clientY;
        
        requestRedraw();
        return;
      }

      // Handle hover detection (only if not dragging)
      if (!isDragging && !isDraggingNode) {
        canvas.className = "infinite-canvas";
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const hoveredNodeNow = getHoveredNode(mouseX, mouseY);
        
        if (hoveredNodeNow && hoveredNodeNow !== hoveredNode) {
          hoveredNode = hoveredNodeNow;
          showHoverPanel(hoveredNode, mouseX, mouseY);
        } else if (!hoveredNodeNow && hoveredNode) {
          hideHoverPanel();
        }
      }
    });

    canvas.addEventListener("mouseleave", () => {
      hideHoverPanel();
      
      // Reset drag states if mouse leaves canvas
      isDragging = false;
      isDraggingNode = false;
      draggedNode = null;
      dragStartTime = 0;
      lastNodeX = 0;
      lastNodeY = 0;
      canvas.className = "infinite-canvas";
    });

    canvas.addEventListener("mouseup", (e) => {
      // Handle node click vs drag
      if (draggedNode && !isDraggingNode) {
        // This was a click, not a drag - trigger toggle
        const timeDiff = Date.now() - dragStartTime;
        if (timeDiff < dragThreshold) {
          toggleNode(draggedNode.id);
          showTermDetails(draggedNode.id);
        }
      }
      
      // Reset all drag states
      isDragging = false;
      isDraggingNode = false;
      draggedNode = null;
      dragStartTime = 0;
      lastNodeX = 0;
      lastNodeY = 0;
      
      // Reset cursor
      canvas.className = "infinite-canvas";
    });

    // Zoom functionality
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // Calculate zoom
      const zoomDelta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
      const newZoom = Math.max(minZoom, Math.min(maxZoom, zoomLevel + zoomDelta));
      
      if (newZoom !== zoomLevel) {
        // Zoom towards mouse position
        const mouseWorldX = (mouseX - panX) / zoomLevel;
        const mouseWorldY = (mouseY - panY) / zoomLevel;
        
        zoomLevel = newZoom;
        
        // Adjust pan to keep mouse position stable
        panX = mouseX - (mouseWorldX * zoomLevel);
        panY = mouseY - (mouseWorldY * zoomLevel);
        
        requestRedraw();
      }
    });

    async function init() {
      console.log("Initializing mind map...");
      
      // Initialize hover panel
      initHoverPanel();
      
      // Position root terms with more spacing to avoid initial overlap
      const positions = [
        { x: 200, y: 200 },   // Top-left
        { x: 500, y: 200 },   // Top-right  
        { x: 350, y: 400 }    // Bottom-center
      ];

      for (let i = 0; i < ROOT_TERMS.length; i++) {
        const rootId = ROOT_TERMS[i];
        const term = await fetchGOTerm(rootId);
        
        if (term) {
          const node = {
            id: rootId,
            lbl: term.lbl || rootId,
            x: positions[i].x,
            y: positions[i].y,
            parent: null,
            pred: null,
            children: [],
            childrenLoaded: false,
            visible: true,
            hasChildren: true
          };
          
          nodes[rootId] = node;
          console.log(`Added root node: ${term.lbl}`);
        }
      }
      
      // Initial draw
      redrawCanvas();
      console.log("Initial draw complete");
    }

    // Start when page loads
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>